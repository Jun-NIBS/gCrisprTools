#This document contains functions for the RRAa algorithm. 

##' @title Calculate default number of cores to use in RRAa aggregation. 
##' @description This function calculates default number of cores to use. Default is 4, unless
##' LSB_DJOB_NUMPROC envvar is available, in which case it is 2 times that number. This code was
##' stolen wholesale from the \code{shRNASeqExpressionPlot} package developed by Brad Friedman. 
##' 
##' @return 1 or \code{2*$LSB_DJOB_NUMPROC}
##' @import parallel
##' @author Brad Friedman
ct.default.numcores <- function()  {
    numcores = Sys.getenv("LSB_DJOB_NUMPROC")
    if (numcores == "") {
        numcores = 2L
    } else {
        if ( Sys.getenv("LSB_INTERACTIVE") == "Y" ) {
            numcores = parallel::detectCores()
        } else {
            numcores = as.integer(numcores)
        }
    }
    return(numcores)
}

##' @title Aggregation of P-value Ranks using a Beta Distribution and Alpha Cutoff  
##' @description This function calculates an alpha-modified rho statistic from a set of ranks on the unit interval by comparing them to a uniform distribution. 
##' Specifically, the ranks are ordered and p-values calculated at each position in the ordered vector by comparison to a Beta distribution. The rho value 
##' returned is the smallest p-value identified in this comparison, only considering the first 'sigs'-ranked values. Should not be used by end users.
##' @param p.in A single column matrix of rank scores, with row.names indicating the gRNA labels.
##' @param sigs The number of ranks to be considered. 
##' @return A numeric rho value corresponding to the minimum rank order P. 
##' @author Russell Bainer
##' @import RobustRankAggreg
##' @examples
##' testp <- runif(20)
##' testsig <- sum(testp <= 0.1)
##'
##' RobustRankAggreg::betaScores((testp))
##' ct.alphaBeta(testp, testsig)  
##' @export

ct.alphaBeta <- function(p.in, sigs){
  #Input checks  
  if(sigs > length(p.in)){stop("You haven't provided enough p-values for the specified number of significant elements.")}
    
    #Function
    if(sigs < 1){
        return(1)
    } else {
          scores <- RobustRankAggreg::betaScores(p.in)
          return(min(scores[1:sigs]))
      }
}

##' @title Aggregation of P-value Ranks using a Beta Distribution and Alpha Cutoff  
##' @description This function is called internally as a single instance of the beta aggregation step in RRAa. Users should not interact with it directly. 
##' A previous version of this function accepted p-values, but that functionality has been moved upstream and now the expected input is a list of ranking statistics. 
##' @param p A single column matrix of rank statistics, with row.names indicating the gRNA labels. 
##' @param g.key data.frame with guide and gene names
##' @param alpha The alpha cutoff parameter, corresponding to the P-value threshold or fold change proportion at which gRNAs should no longer be considered to be 
##' differentially expressed. Alternatively, this can be provided as a named \code{list} or listlike object where the names correspond to the genes in \code{g.key} and the elements are integers indicating the number 
##' of significant gRNAs targeting it. When provided in list form, the elements of \code{alpha} should be provided in the order of the \code{levels()} of g.key$geneSymbol.
##' @param shuffle Logical indicating whether to shuffle the rank statistics prior to calculating the rho statistics (useful for permutation).
##' @param return.obj Name of the environment to record results in, or 'vector' to return the RRAa results directly. \code{'vector'} causes the function to return a numeric vector of genewise rho statistics. Otherwise, the function will directly
##' increment the \code{target.positive.iterations} on the basis of the \code{obs} variable in the specified \code{environment}. 
##' @return Nothing, or a named list of target-level P-values, which are treated as a rho statistic in the permutation step. 
##' @author Russell Bainer
##' @examples 
##' data('fit')
##' data('ann')
##' geneScores <- ct.RRAalpha(fit$p.value, ann, alpha = 0.1, shuffle = FALSE, return.obj = TRUE)
##' @export

ct.RRAalpha <- function(p, g.key, alpha, shuffle = FALSE, return.obj = TRUE){
  
  #determine the input format
  if(length(alpha) == 1){
    
    ##tally the significant genes
    pa <- p[,1] <= alpha
    pass <- tapply(pa, g.key$geneSymbol, sum, simplify=FALSE)
    
  }else{
    pass <- alpha  
  }
  
  if(shuffle){
    p <- sample(p, nrow(p))
  }
  
  #compile list-like object of pvalues for each target
  p.collect <- split(p, g.key$geneSymbol)
  rhoscores <- mapply(ct.alphaBeta, p.collect, pass)
  if(!is.environment(return.obj) | deparse(substitute(return.obj)) %in% 'none'){
    return(rhoscores)
  } else {
    observations <- get('obs', envir = return.obj, mode = 'numeric')
    passcount <- get('target.positive.iterations', envir = return.obj, mode = 'numeric')
    passcount[rhoscores <= observations] <- passcount[rhoscores <= observations] + 1
    assign('target.positive.iterations', passcount, envir = return.obj)
    invisible()
  }
}  



##' @title gRNA signal aggregation via RRAa, optionally using multiple cores. 
##' @description This is a wrapper function implementing the RRAalpha p-value aggregation algorithm. Takes in a set of gRNA rank scores (formatted as a single-column 
##' numeric matrix with row.names indicating the guide names) and a list object of gRNA annotations (names are the gene targets, and each element of the list contains 
##' a vector of the corresponding guide names). The rank scores are converted to gene-level statistics that are thenm transformed into empirical p-values by permutation. 
##' @param p A single column matrix of ranking scores, with row.names indicating the gRNA labels
##' @param g.key An annotation data frame of gRNAs, minimally containing a factorized "geneSymbol" column indicating the target names. This is typically generated by calling the \code{ct.buildKeyFromAnnotation()} function.  
##' @param alpha The alpha cutoff parameter, corresponding to the P-value threshold or the proportion of fold changes at which gRNAs should no longer be considered differentially 
##' expressed. Alternatively, this can be provided as a named \code{list} or listlike object where the names correspond to the genes in \code{g.key} and the elements are 
##' integers indicating the number of significant gRNAs targeting it. When provided in list form, the elements of \code{alpha} will be coerced to the order 
##' of the \code{levels()} of g.key$geneSymbol.
##' @param permute Number of permutations to be used during empirical p-value estimation. In a multicore context the exact number of permutations may vary somewhat
##' to accomodate the corresponding system archetecture but should be close to the specified permutation number. 
##' @param multicore Logical indicating whether to use multiple cores to calculate p-values.
##' @param core.perm Maximum number of permutations to run on each core (only relevant when \code{multicore} is \code{TRUE}). 
##' @param permutation.seed numeric seed for permutation reproducibility.
##'   Default: \code{NULL} means to not set any seed.
##' @return A named list of target-level empirical P-values. 
##' @author Russell Bainer
##' @examples 
##' data('fit')
##' data('ann')
##' genePvals <- ct.RRAaPvals(fit$p.value, ann, alpha = 0.1, permute = 100, multicore = FALSE)
##' genePvals <- ct.RRAaPvals(fit$p.value, ann, alpha = 0.1, permute = 100, multicore = TRUE, core.perm = 10)
##' @export
ct.RRAaPvals <- function(p,
                         g.key,
                         alpha,
                         permute,
                         multicore = TRUE,
                         core.perm = 100,
                         permutation.seed = NULL) {
  
  #Input checks
  if(class(p) != "matrix" | is.null(ncol(p))){
    stop("P-values should be input as a single-column matrix with row names contained in the gs.list")}
  if(ncol(p) > 1){
    warning(paste('Multiple columns are present in the p-value matrix. Using the first column:', colnames(p)[1]))}
  if(!is.numeric(core.perm) | length(core.perm) > 1){
    stop('core.perm must be supplied as a single numeric value.')
  }
  
  if(length(alpha) > 1){
    
    if(!is.list(alpha)){
      stop("alpha must be provided as a single numeric value or a named list of numeric values.")
    }
    if(!setequal(names(alpha), unique(g.key$geneSymbol))){
      stop("When provided as a list, alpha must contain exactly one named element for each gene present in the 'geneSymbol' column of the annotation file.")
    }
    if(!all(unlist(lapply(alpha, is.integer)))){
      stop("When provided as a list, alpha cannot contain non-integer elements.")
    }    
    alpha <- alpha[levels(g.key$geneSymbol)]   
    
  }else{      
    if(!is.numeric(alpha) | (length(alpha) != 1)){
      stop("If not provided as a list, the alpha parameter must be a single numeric value.")
    }
  }
  
  if(!is.data.frame(g.key)){stop("The annotation provided must be a data frame.")}
  if(!("geneSymbol" %in% names(g.key))){stop("The provided annotation does not contain a geneSymbol column.")}
  if(!setequal(row.names(g.key), row.names(p))){stop("Provided p-value list and annotation object contain different elements.")}
  
  is.null(permutation.seed) ||
    is.numeric(permutation.seed) ||
    stop("'permutation.seed' must be numeric or NULL.")
  
  #Everything apparently ok, generate P-values. 
  result.environment <- new.env()

  result.environment$obs <- ct.RRAalpha(p, g.key, alpha, return.obj = 'none')
  nguides <- nrow(p)
  resgenes <- levels(g.key$geneSymbol)
  result.environment$ngenes <- length(resgenes)
  result.environment$target.positive.iterations <- rep(0, result.environment$ngenes)

  if(multicore){
    #figure out the right number of jobs to send to each core
    cores <- ct.default.numcores()
    jpc <- min(floor(permute/cores), core.perm)
    if(jpc == 0){jpc <- 1}
    njobs <- ceiling(permute/jpc)
    permute <- jpc * njobs 
    
    if (is.null(permutation.seed)) {
      batch.perm.seeds <- NULL
    } else {
      # generate a seed for each permutation batch
      batch.perm.seeds <-
        seq(from = permutation.seed, to = permutation.seed + njobs - 1)
    } 
    
    message(paste("Permuting", permute, 'times, using', cores, 'cores.'))
    out <-
      mclapply(1:njobs, function(x) {
        ct.RRAalphaBatch(
          p,
          g.key,
          alpha,
          result.environment,
          batch.size = jpc,
          permutation.seed = batch.perm.seeds[x] 
        )
      }, mc.preschedule = FALSE, mc.cores = cores) 
    result.environment$target.positive.iterations <- rowSums(as.data.frame(out))
    } else {
      set.seed(permutation.seed) # default NULL will have no effect
      message(paste("Permuting", permute, 'times, this may take a while...'))
      iter <- (replicate(permute, ct.RRAalpha(p, g.key, alpha, shuffle = TRUE, return.obj = 'none'))) 
      result.environment$target.positive.iterations <- unlist(lapply(1:nrow(iter), function(x){sum(iter[x,] <= result.environment$obs[x])}))
      }

  out <- result.environment$target.positive.iterations/permute
  names(out) <- names(result.environment$obs)
  return(out)
}

##Previous version of the above function, which works fine for small screens. 
#ct.RRAaPvals <- function(p, g.key, alpha, permute, multicore = TRUE){
#
#  #Input checks
#  if(class(p) != "matrix" | is.null(ncol(p))){
#    stop("P-values should be input as a single-column matrix with row names contained in the gs.list")}
#  if(ncol(p) > 1){
#    warning(paste('Multiple columns are present in the p-value matrix. Using the first column:', colnames(p)[1]))}
#  
#  if(length(alpha) > 1){
#
#      if(!is.list(alpha)){
#        stop("alpha must be provided as a single numeric value or a named list of numeric values.")
#        }
#      if(!setequal(names(alpha), unique(g.key$geneSymbol))){
#        stop("When provided as a list, alpha must contain exactly one named element for each gene present in the 'geneSymbol' column of the annotation file.")
#        }
#      if(!all(unlist(lapply(alpha, is.integer)))){
#        stop("When provided as a list, alpha cannot contain non-integer elements.")
#        }    
#      alpha <- alpha[levels(g.key$geneSymbol)]   
#  
#    }else{      
#      if(!is.numeric(alpha) | (length(alpha) != 1)){
#          stop("If not provided as a list, the alpha parameter must be a single numeric value.")
#        }
#      }
#  
#  if(!is.data.frame(g.key)){stop("The annotation provided must be a data frame.")}
#  if(!("geneSymbol" %in% names(g.key))){stop("The provided annotation does not contain a geneSymbol column.")}
#  if(!setequal(row.names(g.key), row.names(p))){stop("Provided p-value list and annotation object contain different elements.")}
#  
#  #Everything apparently ok, generate P-values. 
#  obs <- ct.RRAalpha(p, g.key, alpha)
#  nguides <- nrow(p)
#  resgenes <- levels(g.key$geneSymbol)
#  ngenes <- length(resgenes)
#    
#  if(multicore){
#    cores <- ct.default.numcores()
#    message(paste("Permuting", permute, 'times, using', cores, 'cores.'))
#
#    shuffled <- replicate(permute, as.matrix(p[sample(1:nguides, nguides, replace = FALSE),]), simplify = FALSE)
#    
#    shuffled.pvals <- mclapply(shuffled, ct.RRAalpha, g.key, alpha, mc.cores = cores) 
#    shuffled.mat <- do.call(cbind, shuffled.pvals)
#    perm <- t(shuffled.mat[resgenes,])
#
#  } else {
#    
#    message(paste("Permuting", permute, 'times, this may take a while...'))
#    perm <- t(vapply(1:permute, function(x){ct.RRAalpha(as.matrix(p[sample(1:nguides, nguides, replace = FALSE),]), g.key, alpha)}, numeric(ngenes)))  
#  }
#  return(vapply(names(obs), function(x, obs, perm){sum(perm[,x] <= obs[x])}, numeric(1), obs, perm)/permute)
#}


##' @title Create Batches of Null Permutations for a Crispr Screen
##' @description This is a wrapper function to partition batches of calls to \code{ct.RRAalpha()} for multicore processing. 
##' It is called internally as a single instance of the beta aggregation step in RRAa. Users should not interact with it directly. 
##' @param p A single column matrix of rank statistics, with row.names indicating the gRNA labels. 
##' @param g.key data.frame with guide and gene names
##' @param alpha The alpha cutoff parameter, corresponding to the P-value threshold or fold change proportion at which gRNAs should no longer be considered to be 
##' differentially expressed. Alternatively, this can be provided as a named \code{list} or listlike object where the names correspond to the genes in \code{g.key} and the elements are integers indicating the number 
##' of significant gRNAs targeting it. When provided in list form, the elements of \code{alpha} should be provided in the order of the \code{levels()} of g.key$geneSymbol.
##' @param result.environment The target environment containing the quasi-global variables incremented during the permutations in the child functions. 
##' @param batch.size Number of iterations to deploy to each daughter process. 
##' @param permutation.seed numeric seed for permutation reproducibility. Default is \code{NULL}, in which case no seed is set.
##' @return An integer vector indicating the number of iterations in which each gene's score was better than those indicated in \code{result.environment$obs}. 
##' @author Russell Bainer
##' @examples 
##' data('fit')
##' data('ann')
##' batch.size <- 50
##' env <- new.env()
##' env$obs <- ct.RRAalpha(fit$p.value, ann, alpha = 0.1, return.obj = 'none')
##' env$ngenes <- length(levels(ann$geneSymbol))
##' passed <- ct.RRAalphaBatch(fit$p.value, ann, alpha = 0.1, result.environment = env, batch.size = batch.size)
##' hist(passed/batch.size, main = 'Empirical P-value', xlab = 'P')
##' @export

ct.RRAalphaBatch <- function(p, g.key, alpha, result.environment, batch.size = 100, 
                             permutation.seed = NULL){
  
  #make a batch environment
  batch.env <- new.env()
  batch.env$obs <- result.environment$obs
  batch.env$target.positive.iterations <- rep(0, result.environment$ngenes)
  
  #run permutations and increment as needed
  set.seed(permutation.seed) # default NULL will have no effect
  invisible(replicate(batch.size, ct.RRAalpha(p, g.key, alpha, shuffle = TRUE, return.obj = batch.env))) 
  
  return(batch.env$target.positive.iterations)
}
