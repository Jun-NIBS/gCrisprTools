##' @title Generate a Receiver-Operator Characteristic (ROC) Curve from a CRISPR screen  
##' @description Given a set of targets of interest, this function generates a ROC curve and associated statistics from the results of 
##' a CRISPR screen. Specifically, it orders the genes targeted in the screen by the specified statistic, and then plots the cumulative
##' proportion of positive hits on the y-axis. The corresponding vextors and Area Under the Curve (AUC) statistic are returned as a list.
##' 
##' Note that ranking statistics in CRISPR screens are (usually) permutation-based, and so some granularity in the rankings is expected. This 
##' function does a little extra work to ensure that hits are counted as soon as the requisite value of the ranking statistic is reached 
##' regardless of where the gene is located within the block of equally-significant genes. Functionally, this means that the drawn curve is
##' somewhat anticonservative in cases where the gene ranks are not well differentiated.  
##'
##' @param summaryDF A dataframe summarizing the results of the screen, returned by the function \code{\link{ct.generateResults}}. 
##' @param gene.list Something coercible to a character vector of target genes that are expected to score highly within the screen. 
##' All elements should be present within the \code{geneSymbol} column of \code{summaryDF}. 
##' @param stat The statistic to use when ordering the genes. Must be one of \code{"enrich.p"}, \code{"deplete.p"}, \code{"enrich.fc"}, 
##' or \code{"deplete.fc"}. 
##' @param condense Logical indicating whether the returned x and y coordinates should be "condensed", returning only the points at which 
##' the detected proportion of \code{gene.list} changes. If set to \code{FALSE}, the returned \code{x} and \code{y} vectors will explicitly
##' indicate the curve value at every position (useful for performing curve arithmetic downstream).   
##' @return A list containing the the x and y coordinates of the curve, and the AUC statistic.
##' @author Russell Bainer
##' @export

ct.ROC <-
  function(summaryDF,
           gene.list,
           stat = c("enrich.p", "deplete.p", "enrich.fc", "deplete.fc"),
           condense = TRUE) {
    
  
  #Check the input: 
    if(!setequal(names(summaryDF), c("symbol","target","geneID","geneSymbol","gRNA Log2 Fold Change","gRNA Depletion P",
                                     "gRNA Depletion Q","gRNA Enrichment P","gRNA Enrichment Q", "Gene-level Enrichment P",
                                     "Gene-level Enrichment Q", "Gene-level Depletion P",  "Gene-level Depletion Q",
                                     "Median log2 Fold Change"))){
      stop("Please supply a summaryDF object generated from ct.generateResults() in the gCrisprTools package.")
    }

    #Convert to gene-level stats
    summaryDF <- summaryDF[!duplicated(summaryDF$geneID),]
    row.names(summaryDF) <- summaryDF$geneID
    
    if(!is.character(gene.list)){
      warning("Supplied gene.list is not a character vector. Coercing.")
      gene.list <- as.character(gene.list)
    }
    present <- intersect(gene.list, summaryDF$geneSymbol)
    if(length(present) != length(gene.list)){
      if(length(present) < 1){
        stop("None of the genes in the input list are present in the geneSymbol column of the input data.frame.")
        }
      warning(paste(length(present), "of", length(gene.list), "genes are present in the supplied results data.frame. Ignoring the remainder of the gene.list."))
    }
    
    #Gather the values for the targets: 
    stat <- match.arg(stat)
    targvals <- switch(stat, 
         enrich.p = (summaryDF[(summaryDF$geneSymbol %in% present),"Gene-level Enrichment P"]), 
         deplete.p = (summaryDF[(summaryDF$geneSymbol %in% present),"Gene-level Depletion P"]), 
         enrich.fc = (-summaryDF[(summaryDF$geneSymbol %in% present),"Median log2 Fold Change"]), 
         deplete.fc = (summaryDF[(summaryDF$geneSymbol %in% present),"Median log2 Fold Change"])
        )   
    #Extract the appropriate stat. 
    values <- switch(stat, 
        enrich.p = sort(summaryDF[,"Gene-level Enrichment P"]), 
        deplete.p = sort(summaryDF[,"Gene-level Depletion P"]), 
        enrich.fc = sort(-summaryDF[,"Median log2 Fold Change"]), 
        deplete.fc = sort(summaryDF[,"Median log2 Fold Change"])
        )

    out <- list()
    out$x <- c(0, which(!duplicated(values)), length(values))
    out$y <- c(0, unlist(lapply(unique(values), function(x){sum(targvals <= x, na.rm = TRUE)/length(targvals)})), 1)
    
    #Calculate the AUC
    binWidth <- out$x[2:length(out$x)] - out$x[1:(length(out$x) - 1)]
    out$AUC <- sum(out$y[1:(length(out$x) - 1)] * binWidth)/length(values)

    #Plot it
    plot(out$x, out$y, xlim = c(0, length(values)), ylim = c(0,1), 
         type = "l", ylab = "Proportion Detected", xlab = "Target Rank", 
         main = paste("AUC:", round(out$AUC, 3)), col = "blue", lwd = 3)
    abline(0, 1/length(values), lty = "dashed", col = "red")
    
    if(!condense){
      out <- .rocXY(out)
    }
    
    return(out)
    }

 
.rocXY <- function(roc){
  elements <- 0:max(roc$x)
  y <- lapply(elements, function(value){
    pos <- length(roc$x[roc$x <= value])
    return(roc$y[pos])
  })
  
  return(list(x = elements, y = unlist(y), AUC = roc$AUC))
}

  
  
  
  
  
  
  
  



