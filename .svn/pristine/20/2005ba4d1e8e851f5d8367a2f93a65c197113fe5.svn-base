#This document contains functions for the RRAa algorithm. 

##' @title Calculate default number of cores to use in RRAa aggregation. 
##' @description This function calculates default number of cores to use. Default is 4, unless
##' LSB_DJOB_NUMPROC envvar is available, in which case it is 2 times that number. This code was
##' stolen wholesale from the \code{shRNASeqExpressionPlot} package developed by Brad Friedman. 
##' 
##' @return 1 or \code{2*$LSB_DJOB_NUMPROC}
##' @import parallel
##' @author Brad Friedman

ct.default.numcores <- function()  {
  lsf.numproc <- Sys.getenv("LSB_DJOB_NUMPROC")

  if(lsf.numproc == "")  {
    numcores <- parallel::detectCores()
  }  else  {
    numcores <- 2*as.integer(lsf.numproc)
  }
  return(numcores)
}

##' @title Aggregation of P-value Ranks using a Beta Distribution and Alpha Cutoff  
##' @description This function calculates an alpha-modified rho statistic from a set of ranks on the unit interval by comparing them to a uniform distribution. 
##' Specifically, the ranks are ordered and p-values calculated at each position in the ordered vector by comparison to a Beta distribution. The rho value 
##' returned is the smallest p-value identified in this comparison, only considering the first 'sigs'-ranked values. Should not be used by end users.
##' @param p.in A single column matrix of rank scores, with row.names indicating the gRNA labels.
##' @param sigs The number of ranks to be considered. 
##' @return A numeric rho value corresponding to the minimum rank order P. 
##' @author Russell Bainer
##' @export

ct.alphaBeta <- function(p.in, sigs){
  #Input checks  
  if(sigs > length(p.in)){stop("You haven't provided enough p-values for the specified number of significant elements.")}
    
    #Function
    if(sigs < 1){
        return(1)
    } else {
          scores <- betaScores(p.in)
          return(min(scores[1:sigs]))
      }
}

##' @title Aggregation of P-value Ranks using a Beta Distribution and Alpha Cutoff  
##' @description This function is called internally as a single instance of the beta aggregation step in RRAa. Users should not interact with it directly. 
##' A previous version of this function accepted p-values, but that functionality has been moved upstream and now the expected input is a list of ranking statistics. 
##' @param p A single column matrix of rank statistics, with row.names indicating the gRNA labels. 
##' @param g.key data.frame with guide and gene names
##' @param alpha The alpha cutoff parameter, corresponding to the P-value threshold or fold change proportion at which gRNAs should no longer be considered to be 
##' differentially expressed. Alternatively, this can be provided as a named \code{list} or listlike object where the names correspond to the genes in \code{g.key} and the elements are integers indicating the number 
##' of significant gRNAs targeting it. When provided in list form, the elements of \code{alpha} should be provided in the order of the \code{levels()} of g.key$geneSymbol.
##' @return A named list of target-level P-values, which are treated as a rho statistic in the permutation step. 
##' @author Russell Bainer
##' @export

ct.RRAalpha <- function(p, g.key, alpha){
  
  #determine the input format
  if(length(alpha) == 1){
  
    ##tally the significant genes
    pa <- p[,1] <= alpha
    pass <- tapply(pa, g.key$geneSymbol, sum, simplify=FALSE)
   
  }else{
    pass <- alpha  
  }
    
  #compile list-like object of pvalues for each target
  p.collect <- split(p, g.key$geneSymbol )
    
  #determine the adjusted rho value
  return(mapply(ct.alphaBeta, p.collect, pass))
  
}


##' @title gRNA signal aggregation via RRAa, optionally using multiple cores. 
##' @description This is a wrapper function implementing the RRAalpha p-value aggregation algorithm. Takes in a set of gRNA rank scores (formatted as a single-column 
##' numeric matrix with row.names indicating the guide names) and a list object of gRNA annotations (names are the gene targets, and each element of the list contains 
##' a vector of the corresponding guide names). The rank scores are converted to gene-level statistics that are thenm transformed into empirical p-values by permutation. 
##' @param p A single column matrix of ranking scores, with row.names indicating the gRNA labels
##' @param g.key An annotation data frame of gRNAs, minimally containing a factorized "geneSymbol" column indicating the target names. This is typically generated by calling the \code{ct.buildKeyFromAnnotation()} function.  
##' @param alpha The alpha cutoff parameter, corresponding to the P-value threshold or the proportion of fold changes at which gRNAs should no longer be considered differentially 
##' expressed. Alternatively, this can be provided as a named \code{list} or listlike object where the names correspond to the genes in \code{g.key} and the elements are 
##' integers indicating the number of significant gRNAs targeting it. When provided in list form, the elements of \code{alpha} will be coerced to the order 
##' of the \code{levels()} of g.key$geneSymbol.
##' @param permute Number of permutations to be used during empirical p-value estimation. 
##' @param multicore Logical indicating whether to use multiple cores to calculate p-values. 
##' @return A named list of target-level empirical P-values. 
##' @author Russell Bainer
##' @export

ct.RRAaPvals <- function(p, g.key, alpha, permute, multicore = TRUE){

  #Input checks
  if(class(p) != "matrix" | is.null(ncol(p))){
    stop("P-values should be input as a single-column matrix with row names contained in the gs.list")}
  if(ncol(p) > 1){
    warning(paste('Multiple columns are present in the p-value matrix. Using the first column:', colnames(p)[1]))}
  
  if(length(alpha) > 1){

      if(!is.list(alpha)){
        stop("alpha must be provided as a single numeric value or a named list of numeric values.")
        }
      if(!setequal(names(alpha), unique(g.key$geneSymbol))){
        stop("When provided as a list, alpha must contain exactly one named element for each gene present in the 'geneSymbol' column of the annotation file.")
        }
      if(!all(unlist(lapply(alpha, is.integer)))){
        stop("When provided as a list, alpha cannot contain non-integer elements.")
        }    
      alpha <- alpha[levels(g.key$geneSymbol)]   
  
    }else{      
      if(!is.numeric(alpha) | (length(alpha) != 1)){
          stop("If not provided as a list, the alpha parameter must be a single numeric value.")
        }
      }
  
  if(!is.data.frame(g.key)){stop("The annotation provided must be a data frame.")}
  if(!("geneSymbol" %in% names(g.key))){stop("The provided annotation does not contain a geneSymbol column.")}
  if(!setequal(row.names(g.key), row.names(p))){stop("Provided p-value list and annotation object contain different elements.")}
  
  #Everything apparently ok, generate P-values. 
  obs <- ct.RRAalpha(p, g.key, alpha)
  nguides <- nrow(p)
  resgenes <- levels(g.key$geneSymbol)
  ngenes <- length(resgenes)
    
  if(multicore){
    cores <- ct.default.numcores()
    message(paste("Permuting", permute, 'times, using', cores, 'cores.'))

    shuffled <- replicate(permute, as.matrix(p[sample(1:nguides, nguides, replace = FALSE),]), simplify = FALSE)
    
    shuffled.pvals <- mclapply(shuffled, ct.RRAalpha, g.key, alpha, mc.cores = cores) 
    shuffled.mat <- do.call(cbind, shuffled.pvals)
    perm <- t(shuffled.mat[resgenes,])

  } else {
    
    message(paste("Permuting", permute, 'times, this may take a while...'))
    perm <- t(vapply(1:permute, function(x){ct.RRAalpha(as.matrix(p[sample(1:nguides, nguides, replace = FALSE),]), g.key, alpha)}, numeric(ngenes)))  
  }
  return(vapply(names(obs), function(x, obs, perm){sum(perm[,x] <= obs[x])}, numeric(1), obs, perm)/permute)
}















