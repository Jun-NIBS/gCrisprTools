##' Combine CRISPR counts by SAMID
##'
##' Sometimes a CRISPR sample (SAMID) is split across lanes/runs. This
##' function will sum up the counts by SAMID and return a new ExpressionSet
##' or CountDataSet.
##'
##' It is assumed that the sampleNames are of the form "SAMID-whatever".
##' @param eset ExpressionSet or CountDataSet
##' @return ExpressionSet or CountDataSet with one column per SAMID
##' @export
##' @author Sarah Kummerfeld
merge.lanes <- function(eset) {
    sams = gsub("-.*", "", sampleNames(eset))
    usams = unique(sams)
    if(class(eset) == "CountDataSet") {
        newExp = matrix(nrow=length(featureNames((eset))),ncol=length(usams),
                        dimnames=list(rownames(counts(eset)), usams))
        oldExp = counts(eset)
    } else {
        newExp = matrix(nrow=length(featureNames((eset))),ncol=length(usams),
                        dimnames=list(rownames(exprs(eset)), usams))
        oldExp = exprs(eset)
    }
    samtab = table(sams)
    for(sam in names(samtab[samtab > 1]))
    {
        subset = oldExp[,which(sams == sam)]
        newExp[,sam] = apply(subset, 1, sum)
    }
    for(sam in names(samtab[samtab == 1]))
    {
        newExp[,sam] = oldExp[,which(sams == sam)]
    }
    newInd = c()
    for(sam in usams)
    {
        newInd = c(newInd, which(sams == sam)[1])
    }
    newPdata = pData(eset)[newInd,]
    newPdata = newPdata[,setdiff(colnames(newPdata), c("sizeFactor","sizeFactor.crispr-gRNA"))]
    rownames(newPdata) <- newPdata$laneId <-  usams
    if(class(eset) == "CountDataSet") {
        res = newCountDataSet(newExp, conditions=newPdata, featureData = featureData(eset))

    } else {
        res = ExpressionSet(newExp, phenoData=AnnotatedDataFrame(newPdata),
                            featureData=featureData(eset), annotation=annotation(eset))
    }
    res
}

## Based on shRNASeqExpressionPlot::shRNA.to.expressionplot
CRISPR.to.expressionplot <- function (basedir, counts.json.files, annot.id, annot = load.annot(annot.id), 
    target.field = "target", pheno, comp.specs = list(), organism, 
    title, abstract = title, people = NULL, links = NULL, umask = "0022", 
    defaults = load.epi.defaults(), comp.stats.meta.id = "/stats_meta/deseq.tsv", 
    logger = default.logger(), read.class.annot.id = "/RNASeq/shRNASeq_classes.tsv", 
    shRNA.feature.type = "shRNA", platform = "shRNASeq", allow.mixed.strand = FALSE, 
    allow.mixed.libtype = FALSE, libtype.field.name = "library_type", 
    ...) 
{
    file.exists(basedir) && stop("basedir '", basedir, "' already exists")
    missing(organism) && stop("You must supply an organism, like \"Human\" or \"Mouse\"")
    info(logger, "shRNASeq.to.expressionplot()")
    if (!identical(rownames(pheno), names(counts.json.files))) {
        stop("pheno rownames do not agree with counts.json.files names.\npheno rownames:\n  ", 
            paste(collapse = "\n  ", rownames(pheno)), "\n\nnames(counts.json.files):\n  ", 
            paste(collapse = "\n  ", names(counts.json.files)))
    }
    counts <- lapply(counts.json.files, function(fn) {
        struct <- fromJSON(readLines(fn))
        for (field in c("targets", "rejections")) struct[[field]] <- simplify2array(struct[[field]])
        return(struct)
    })
    has.fastq2 <- sapply(counts, function(cts) !is.null(cts$fastq2))
    if (any(has.fastq2)) {
        some.paired.end <- TRUE
        if (any(!has.fastq2)) {
            if (!allow.mixed.libtype) 
                stop("You have a mixture of single- and paired-end lanes.\nSingle:\n  ", 
                  paste(collapse = "\n  ", names(counts)[!has.fastq2]), 
                  "\nPaired:\n  ", paste(collapse = "\n  ", names(counts)[has.fastq2]), 
                  "\n  ", "Supply allow.mixed.libtype = TRUE if you want to proceed")
            if (libtype.field.name %in% names(pheno)) 
                stop("'", libtype.file.name, "' is already in the pheno table but you have mixed library types and I am supposed\n", 
                  "to add it in for you. Supply some other name for the field that I'll make for you with libtype.field.name")
            libtype <- ifelse(has.fastq2, "paired", "single")
            stopifnot(names(libtype) == rownames(pheno))
            pheno[[libtype.field.name]] <- factor(libtype, levels = c("single", 
                "paired"))
        }
    }
    else if (all(!has.fastq2)) {
        some.paired.end <- FALSE
    }
    trim.regexes <- .check.trim.regexes(counts)
    minus <- if (allow.mixed.strand) {
        unique(sapply(counts, "[[", "minus"))
    }
    else {
        .check.minus(counts)
    }
    targets <- .check.and.order.targets(counts = counts, annot = annot, 
        target.field = target.field, annot.id = annot.id)
    target.to.fid.map <- setNames(rownames(annot), as.character(annot[[target.field]]))
    paths <- data.frame(counts.json = counts.json.files, fastq = sapply(counts, 
        "[[", "fastq"), row.names = names(counts.json.files), 
        stringsAsFactors = FALSE)
    if (some.paired.end) {
        paths$fastq2 <- sapply(counts, function(cts) {
            fn <- cts$fastq2
            if (is.null(fn)) {
                NA_character_
            }
            else {
                fn
            }
        })
    }
    validate.paths.pheno.comps(paths, pheno, comp.specs, required = c("counts.json", 
        "fastq"), allow.na.paths = if (allow.mixed.libtype) 
        "fastq2"
    else character(0))
    samids <- rownames(paths)
    stopifnot(!is.null(samids))
    info(logger, "shRNASeq.to.expressionplot(): building read class CDS")
    read.class.counts <- do.call(data.frame, c(lapply(counts, 
        function(cts) {
            n <- c(targets = sum(cts$targets), nomatch = cts$nomatch)
            rej <- cts$rejections
            if (some.paired.end) {
                n["rejections"] <- sum(rej[names(rej) != "double_match"])
                n["double_match"] <- if ("double_match" %in% 
                  names(rej)) rej[["double_match"]] else 0
            } else {
                stopifnot(!"double_match" %in% names(rej))
                n["rejections"] <- sum(rej)
            }
            n
        }), list(check.names = FALSE)))
    read.class.cds <- newCountDataSet(read.class.counts, conditions = pheno)
    experimentData(read.class.cds) <- MIAME(title = title, abstract = abstract)
    annotation(read.class.cds) <- platform
    info(logger, paste("shRNASeq.to.expressionplot(): Creating new ExpressionPlot project at '", 
        basedir, "'"))
    proj <- new.ep.project.from.cds(basedir, cds = read.class.cds, 
        people = people, links = links, umask = umask, organism = organism, 
        logger = logger, subclass = c("shRNASeqExpressionPlotProject", 
            "RNASeqExpressionPlotProject"), ...)
    info(logger, "shRNASeq.to.expressionplot(): Adding read class data")
    add.data.from.alignment.class.cds(proj, read.class.cds, defaults = defaults, 
        analyzed.field = "targets", logger = logger, annot.id = read.class.annot.id)
    info(logger, "shRNASeq.to.expressionplot(): Adding shRNA counts feature type")
    shrna.counts <- do.call(data.frame, c(lapply(counts, function(cts) cts$targets[targets]), 
        list(check.names = FALSE)))
    rownames(shrna.counts) <- target.to.fid.map[targets]
    shrna.cds <- newCountDataSet(shrna.counts, conditions = pheno)
    info(logger, "shRNASeq.to.expressionplot(): Analyzing shRNA counts")
    analyze.cds(proj, cds = shrna.cds, comp.specs = comp.specs, 
        feature.type = shRNA.feature.type, comp.stats.meta.id = comp.stats.meta.id, 
        annot.id = annot.id, logger = logger)
    rpkm.stat <- "rpkm"
    if (ep.has.stat(proj, shRNA.feature.type, "samp", rpkm.stat)) {
        info(logger, paste(sep = "", "shRNASeq.to.expressionplot(): Removing RPKMs as they are stupid for this data type"))
        ep.trim.hdf5(proj, feature.type = shRNA.feature.type, 
            groupname = "samp", ids.to.delete = rpkm.stat, what = "stats", 
            logger = logger)
    }
    ep.renormalize(proj)
    info(logger, "Now storing paths to input_files.txt")
    input.files <- cbind(ID = rownames(paths), paths)
    ep.set.input.files(proj, input.files)
    ep.shRNASeq.set.reagent(proj, shRNA.feature.type)
    ep.shRNASeq.set.minus(proj, minus)
    ep.shRNASeq.set.trim.regexes(proj, trim.regexes)
    return(proj)
}
